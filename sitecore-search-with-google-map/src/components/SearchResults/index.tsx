// This component was generated by @sitecore-search/cli on Sat Mar 08 2025 15:39:57 GMT+0530 (India Standard Time)

import type {
  SearchResultsInitialState,
  SearchResultsStoreState,
} from "@sitecore-search/react";
import {
  FilterGeo,
  PageController,
  WidgetDataType,
  useSearchResults,
  useSearchResultsSelectedFilters,
  widget,
} from "@sitecore-search/react";
import Spinner from "../Spinner";
import Filter from "../Filter";
import QueryResultsSummary from "../QueryResultsSummary";
import SearchFacets from "../SearchFacets";
import SortOrder from "../SortOrder";
import ArticleHorizontalItemCard from "../ArticleHorizontalCard";
import ResultsPerPage from "../ResultsPerPage";
import SearchPagination from "../SearchPagination";
import { LoadScript } from "@react-google-maps/api";
import AutoCompleteWrapper from "../../helpers/AutoCompleteWrapper";
import { useEffect, useState } from "react";
import GoogleMap from "../../helpers/GoogleMap";

type ArticleModel = any;
type storesListearchResultsProps = {
  defaultSortType?: SearchResultsStoreState["sortType"];
  defaultPage?: SearchResultsStoreState["page"];
  defaultItemsPerPage?: SearchResultsStoreState["itemsPerPage"];
  defaultKeyphrase?: SearchResultsStoreState["keyphrase"];
  searchSource?: string;
  layout?:
    | "SearchWithInputOnTopWithParallelMapAndContent"
    | "SearchWithInputMapContentStack"
    | "SearchWithInputOnTopWithParallelMapAndContentSmallMap"
    | "SearchWithParallelMapAndInputWithContent"
    | "SearchWithInputOnTopWithParallelMapAndContentReverse"
    | "SearchWithInputOnTopWithParallelMapAndContentSmallMapReverse"
    | "SearchWithParallelMapAndInputWithContentReverse"
    | undefined;
  title?: string;
  noResultFound?: string;
  description?: string;
  inputPlaceholder?: string;
  customArticleRenderer?: (article: any) => JSX.Element;
  mapIcon?: string;
  radiusInKM?: number;
};
type InitialState = SearchResultsInitialState<
  "itemsPerPage" | "keyphrase" | "page" | "sortType"
>;

export const SearchResultsComponent = ({
  defaultSortType = "featured_desc",
  defaultPage = 1,
  defaultKeyphrase = "",
  defaultItemsPerPage = 10,
  searchSource,
  layout,
  title,
  description,
  noResultFound,
  inputPlaceholder,
  mapIcon,
  radiusInKM,
  customArticleRenderer,
}: storesListearchResultsProps) => {
  const [isErrorInStoreData, setIsErrorInStoreData] = useState<boolean>(false);
  const [activeMarker, setActiveMarker] = useState({});
  const selectedFacetsFromApi = useSearchResultsSelectedFilters();
  const searchSourceIds = searchSource?.split("|") || [];
  const [coordinates, setCoordinates] = useState({
    lat: 37.8044,
    lng: -122.2711,
  });
  const [stores, setStores] = useState<ArticleModel[]>([]);

  const [address, setAddress] = useState("");
  const [selectedSuggestions, setSelectedSuggestions] = useState<any>({
    Keywords: "",
  });

  const renderForm = (onAutoSuggestionSubmit: any) => (
    <>
      <form className="relative px-[16px]">
        <input
          aria-label="google-auto-suggestion-address"
          name="google-auto-suggestion-address"
          id="google-auto-suggestion-address"
          value={address}
          placeholder={inputPlaceholder}
          className={
            "input w-full p-4 rounded-2xl shadow-md bg-gray-100 text-gray-800 placeholder-gray-400 border-2 border-transparent focus:border-blue-400 hover:border-blue-400 focus:outline-none transition-all"
          }
          onChange={(e) => {
            setAddress(e?.target?.value);
            setIsErrorInStoreData(false);
          }}
        />
        <button
          aria-label="search"
          onClick={async (e) => {
            e.preventDefault();
            const inputElement = document.getElementById(
              "google-auto-suggestion-address"
            ) as HTMLInputElement;
            if (inputElement) {
              const inputValue = inputElement?.value;
              setAddress(inputValue);
              setIsErrorInStoreData(false);
              if (inputValue) {
                handleSelect(await onAutoSuggestionSubmit(inputValue));
              }
            }
          }}
          className={""}
        ></button>
      </form>
      {/* {isErrorInStoreData && noResultFound && <>{noResultFound}</>} */}
    </>
  );

  const {
    widgetRef,
    actions: { onItemClick },
    state: { sortType, page, itemsPerPage },
    queryResult: {
      isLoading,
      isFetching,
      data: {
        total_item: totalItems = 0,
        sort: { choices: sortChoices = [] } = {},
        facet: facets = [],
        content: storesList = [],
      } = {},
    },
  } = useSearchResults<ArticleModel, InitialState>({
    query: (query) => {
      const geoFilter = new FilterGeo("location", `${radiusInKM || 10}km`);
      query
        .getRequest()
        .setSearchFacetAll(true)
        .setSources(searchSourceIds)
        .setSearchFilter(geoFilter);
    },
    state: {
      sortType: defaultSortType,
      page: defaultPage,
      itemsPerPage: defaultItemsPerPage,
      keyphrase: defaultKeyphrase,
    },
  });
  useEffect(() => {
    if (coordinates?.lat && coordinates?.lng) {
      PageController.getContext().setGeo({
        location: {
          lat: Number(coordinates?.lat),
          lon: Number(coordinates?.lng),
        },
      });
    }
  }, [coordinates]);
  useEffect(() => {
    if (!(isLoading || isFetching)) {
      setStores(storesList);
      if (
        storesList?.length <= 0 &&
        selectedSuggestions?.Keywords?.length > 0
      ) {
        setIsErrorInStoreData(true);
      }
    }
  }, [isLoading, isFetching]);
  const totalPages = Math.ceil(totalItems / itemsPerPage);
  const handleSelect = async (value: any) => {
    setAddress(value?.keyword);
    if (value && value?.isError) {
      setIsErrorInStoreData(true);
    } else if (value?.keyword) {
      setIsErrorInStoreData(false);

      setSelectedSuggestions({
        Keywords: value?.keyword,
      });
      if (!(coordinates?.lat === value.lat && coordinates?.lng === value.lng)) {
        setStores([]);
      }

      if (
        coordinates?.lat === value.lat &&
        coordinates?.lng === value.lng &&
        stores?.length === 0 &&
        storesList?.length > 0
      ) {
        setStores(storesList);
      }
      //TODO: No need to do anything when same latitude and longitude
      else if (
        coordinates?.lat === value.lat &&
        coordinates?.lng === value.lng
      ) {
      } else {
        setCoordinates({ lat: value.lat, lng: value.lng });
      }
    }
  };
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-screen w-full bg-white ">
        <Spinner loading />
      </div>
    );
  }
  const renderInput = () => {
    return (
      <AutoCompleteWrapper
        options={{
          types: ["(regions)"],
          componentRestrictions: {
            country: "us",
          },
          bounds: {
            //This calculates the radius and this will be in static form only
            east:
              coordinates.lng +
              (30000 / 111000) * Math.cos(coordinates.lat * (Math.PI / 180)),
            west:
              coordinates.lng -
              (30000 / 111000) * Math.cos(coordinates.lat * (Math.PI / 180)),
            north: coordinates.lat + 30000 / 111000,
            south: coordinates.lat - 30000 / 111000,
          },
        }}
        addressLine1={address}
        hideSuggestions={address?.length < 3}
        onHandleChange={handleSelect}
      >
        {/*  eslint-disable-next-line @typescript-eslint/no-explicit-any */}
        {({ onAutoSuggestionSubmit }: any) => {
          return renderForm(onAutoSuggestionSubmit);
        }}
      </AutoCompleteWrapper>
    );
  };
  const renderMap = (mapStyles: any) => (
    <GoogleMap
      coordinates={coordinates}
      activeMarker={activeMarker}
      mapStyles={mapStyles}
      setActiveMarker={setActiveMarker}
      mapIcon={mapIcon}
      storeCoordinates={stores?.map((store: ArticleModel) => {
        return {
          id: store?.id,
          latitude: +store?.latitude,
          longitude: +store?.longitude,
        };
      })}
    />
  );
  const renderContent = () => {
    return (
      <div
        ref={widgetRef}
        className="flex relative max-w-full px-4 text-black dark:text-gray-100 text-opacity-75"
      >
        {isFetching && (
          <div className="w-full h-full fixed top-0 left-0 bottom-0 right-0 z-30 bg-white dark:bg-gray-900 opacity-50">
            <div className="absolute top-[50%] left-[50%] -translate-x-[50%] -translate-y-[50%] flex flex-col justify-center items-center z-40">
              <Spinner loading />
            </div>
          </div>
        )}
        {totalItems > 0 && (
          <>
            {selectedFacetsFromApi.length > 0 ||
              (facets?.length > 0 && (
                <section className="flex flex-col flex-none relative mt-4 mr-8 w-[25%]">
                  <Filter />
                  <SearchFacets facets={facets} />
                </section>
              ))}
            <section className="flex flex-col flex-[4_1_0%]">
              {/* Sort Select */}
              <section className="flex justify-between text-xs">
                {totalItems > 0 && (
                  <QueryResultsSummary
                    currentPage={page}
                    itemsPerPage={itemsPerPage}
                    totalItems={totalItems}
                    totalItemsReturned={storesList.length}
                  />
                )}
                <SortOrder options={sortChoices} selected={sortType} />
              </section>

              {/* Results */}
              <div className="w-full">
                {storesList.map((a, index) => (
                  <ArticleHorizontalItemCard
                    key={a.id}
                    setActiveMarker={setActiveMarker}
                    article={a as ArticleModel}
                    index={index}
                    onItemClick={onItemClick}
                    displayText={true}
                    customArticleRenderer={customArticleRenderer}
                  />
                ))}
              </div>
              <div className=" text-black !text-[16px] flex flex-col md:flex-row md:justify-between text-xs">
                <ResultsPerPage defaultItemsPerPage={defaultItemsPerPage} />
                <SearchPagination currentPage={page} totalPages={totalPages} />
              </div>
            </section>
          </>
        )}
        {totalItems <= 0 && !isFetching && (
          <div className="w-full flex pt-[50px] justify-center">
            <h3 className="text-black text-[20px] font-[500]">
              {noResultFound}
            </h3>
          </div>
        )}
      </div>
    );
  };
  const SearchWithInputOnTopWithParallelMapAndContent = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        {renderInput()}
        <div className="flex ">
          <div className="min-w-[50%]">
            {renderMap({
              height: "500px",
              width: "100%",
              borderRadius: "30px",
            })}
          </div>
          <div className="min-w-[50%]">{renderContent()}</div>
        </div>
      </>
    );
  };
  const SearchWithInputOnTopWithParallelMapAndContentReverse = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        {renderInput()}
        <div className="flex flex-row-reverse">
          <div className="min-w-[50%]">
            {renderMap({
              height: "500px",
              width: "100%",
              borderRadius: "30px",
            })}
          </div>
          <div className="min-w-[50%]">{renderContent()}</div>
        </div>
      </>
    );
  };

  const SearchWithInputMapContentStack = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        {renderInput()}
        {renderMap({
          height: "500px",
          width: "100%",
          borderRadius: "30px",
        })}
        {renderContent()}
      </>
    );
  };

  const SearchWithInputOnTopWithParallelMapAndContentSmallMap = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        {renderInput()}
        <div className="flex ">
          {renderMap({
            height: "500px",
            width: "500px",
            borderRadius: "30px",
          })}
          <div className="w-full"> {renderContent()}</div>
        </div>
      </>
    );
  };
  const SearchWithInputOnTopWithParallelMapAndContentSmallMapReverse = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        {renderInput()}
        <div className="flex flex-row-reverse">
          {renderMap({
            height: "500px",
            width: "500px",
            borderRadius: "30px",
          })}
          <div className="w-full"> {renderContent()}</div>
        </div>
      </>
    );
  };

  const SearchWithParallelMapAndInputWithContent = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}
        <div className="flex ">
          {renderMap({
            height: "500px",
            width: "500px",
            borderRadius: "30px",
          })}
          <div className="w-full">
            {renderInput()}
            {renderContent()}
          </div>
        </div>
      </>
    );
  };

  const SearchWithParallelMapAndInputWithContentReverse = () => {
    return (
      <>
        {title && (
          <p className="title text-[50px] font-[600] mb-[20px] w-full text-center">
            {title}
          </p>
        )}
        {description && (
          <p className="description text-[20px] font-[600] mb-[40px] w-full text-center">
            {description}
          </p>
        )}

        <div className="flex flex-row-reverse">
          {renderMap({
            height: "500px",
            width: "500px",
            borderRadius: "30px",
          })}
          <div className="w-full">
            {renderInput()}
            {renderContent()}
          </div>
        </div>
      </>
    );
  };

  const componentMap = {
    SearchWithInputOnTopWithParallelMapAndContent:
      SearchWithInputOnTopWithParallelMapAndContent,
    SearchWithInputMapContentStack: SearchWithInputMapContentStack,
    SearchWithInputOnTopWithParallelMapAndContentSmallMap:
      SearchWithInputOnTopWithParallelMapAndContentSmallMap,
    SearchWithParallelMapAndInputWithContent:
      SearchWithParallelMapAndInputWithContent,
    SearchWithInputOnTopWithParallelMapAndContentReverse:
      SearchWithInputOnTopWithParallelMapAndContentReverse,
    SearchWithInputOnTopWithParallelMapAndContentSmallMapReverse:
      SearchWithInputOnTopWithParallelMapAndContentSmallMapReverse,
    SearchWithParallelMapAndInputWithContentReverse:
      SearchWithParallelMapAndInputWithContentReverse,
  };

  return (
    <div className="container mx-auto pt-[40px] pb-[80px]">
      <LoadScript
        googleMapsApiKey={process.env.GOOGLE_API_KEY || ""}
        libraries={["places"]}
      >
        {layout && componentMap?.[layout]
          ? componentMap?.[layout]()
          : SearchWithInputOnTopWithParallelMapAndContent()}
        {/* {SearchWithInputOnTopWithParallelMapAndContent()} */}
        {/* {SearchWithInputMapContentStack()} */}
        {/* {SearchWithInputOnTopWithParallelMapAndContentSmallMap()} */}
        {/* {SearchWithParallelMapAndInputWithContent()} */}

        {/* {SearchWithInputOnTopWithParallelMapAndContentReverse()} */}
        {/* {SearchWithInputOnTopWithParallelMapAndContentSmallMapReverse()} */}
        {/* {SearchWithParallelMapAndInputWithContentReverse()} */}
      </LoadScript>
    </div>
  );
};
const SearchResultsWidget = widget(
  SearchResultsComponent,
  WidgetDataType.SEARCH_RESULTS,
  "content"
) as any;
export default SearchResultsWidget;
